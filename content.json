{"meta":{"title":"SCERush","subtitle":"","description":"","author":"SCERush","url":"http://yoursite.com","root":"/"},"pages":[{"title":"All tags","date":"2020-06-01T09:35:37.000Z","updated":"2020-06-01T09:36:29.067Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-01T12:13:54.000Z","updated":"2020-06-01T12:14:57.423Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Tonelli–Shanks Algorithm","slug":"Tonelli–Shanks-Algorithm","date":"2020-06-01T06:27:00.000Z","updated":"2020-06-01T13:22:38.214Z","comments":true,"path":"2020/06/01/Tonelli–Shanks-Algorithm/","link":"","permalink":"http://yoursite.com/2020/06/01/Tonelli%E2%80%93Shanks-Algorithm/","excerpt":"参考：http://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli–Shanks算法是一个求解二次平方根的算法 x^2 \\equiv n \\pmod p其中n是p的二次剩余，p为奇素数","text":"参考：http://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli–Shanks算法是一个求解二次平方根的算法 x^2 \\equiv n \\pmod p其中n是p的二次剩余，p为奇素数 算法输入: p,一个素数 n,一个模p的二次剩余 输出: r, $ r^2 \\equiv n \\pmod p $ 算法: 从p-1分解出2的幂次，即有:p-1=Q*2^S，其中Q是奇素数。如果S=1，即$p \\equiv 3 \\pmod 4$，然后直接返回$r \\equiv \\pm n^{\\frac{p+1}{4}}$。 计算z，使得其满足L(z,p)=-1，令 $c \\equiv z^Q$ 令 $r \\equiv n^{\\frac{Q+1}{2}} , t \\equiv n^Q , m = s$ 循环： 如果$t\\equiv 1$，返回r 否则，找到最小的一个i(0&lt;i&lt;m)，且$t^{2i} \\equiv 1$ 令 $b \\equiv c^{2^{m-i-1}}$，再令 $r\\equiv br$,$t\\equiv tb^2$,$c\\equiv b^2$,$m=i$ 如果得到一个解r，另一个解就是p-r 证明首先有p-1=Q*2^S，令$r\\equiv n^{\\frac{Q+1}{2}}\\pmod{p}, t\\equiv n^Q\\pmod p$，注意到有$r^2\\equiv nt\\pmod p$，这一同余式在每次循环中都保持正确；如果在某一时间点，$t \\equiv 1\\pmod p$，则有$r^2\\equiv n\\pmod p$，于是就找到n的二次平方根$R\\equiv \\pm r\\pmod p$ 如果$t!\\equiv 1\\pmod p$，那就考虑二次非剩余z；令$c\\equiv z^Q\\pmod p$，然后就有$c^{2^S}\\equiv {(z^Q)}^{2^S}\\equiv z^{2^SQ}\\equiv z^{p-1}\\equiv 1\\pmod p$，并且$c^{2^{S-1}}\\equiv z^{\\frac{p-1}{2}}\\equiv -1 \\pmod p$，这意味着c的阶是$2^S$ 类似地，$t^{2^S}\\equiv 1\\pmod p$，故t的阶能整除$2^S$；假设t的阶是$2^{S’}$，由于n是模p的二次剩余，$S’\\leq S-1$ 现在令$b \\equiv c^{2^{m-i-1}}\\pmod p$,$r’\\equiv br\\pmod p$,$c’\\equiv b^2\\pmod p$,$t’\\equiv c’t\\pmod p$,和之前一样，${r’}^2\\equiv nt’ \\pmod p$任然成立；然而现在的t和c’的阶数都是$2^{S’}$，这意味着t’的阶数$2^{S’’}$满足$S’’&lt;S’$ 如果$s’’\\equiv 0\\pmod p$，则$t’\\equiv 1\\pmod p$，算法终止，返回$R\\equiv \\pm r’\\pmod p$，否则重新执行循环，定义$b’,r’’,c’’,t’’$……直到停止；由于S序列严格递减，算法一定会结束 实现(python)123456789101112131415161718192021222324252627282930313233343536373839def legendre(a,p): symbol = pow(a, (p - 1) // 2, p) if symbol == p - 1: return -1 return symboldef tonelli(a,p): if a == 0 or legendre(a,p) != 1: return 0 q = p - 1 s = 0 while q % 2 == 0: q //= 2 s += 1 if s == 1: return pow(n, (p + 1) // 4, p) z = 2 while legendre(z, p) != -1: z += 1 m = s c = pow(z, q, p) t = pow(a, q, p) r = pow(a, (a +1) // 2, p) while t!= 1: t2 = t i = 0 while t2 != 1 and i &lt; m: t2 = pow(t2, 2, p) i += 1 b = pow(c, 2 ** (m - i - 1), p) m = i c = (b * b) % p t = (t * c) % p r = (r * b) % p return r","categories":[],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"RSA基础","slug":"RSA基础","date":"2020-05-30T04:22:24.000Z","updated":"2020-05-31T10:02:34.583Z","comments":true,"path":"2020/05/30/RSA基础/","link":"","permalink":"http://yoursite.com/2020/05/30/RSA%E5%9F%BA%E7%A1%80/","excerpt":"几道基础的RSA题目","text":"几道基础的RSA题目 RSA 题目：在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d作为flga提交 基础题，直接解123456import gmpy2p=473398607161q=4511491e=17d=gmpy2.invert(e,(p-1)*(q-1))print d rsarsa题目给出了RSA的相关参数，直接求解12345678910import gmpy2p = q = e = c = phi = (p - 1) * (q - 1)d = gmpy2.invert(e, phi)n = p * qprint pow(c, d, n) RSA1 p，q，dp，dq，c 脚本如下： 12345678910111213141516import gmpy2import libnump = q = dp = dq = c = n = p*qphi =(p-1)*(q-1)dd = gmpy2.gcd(p-1,q-1)d=(dp-dq)//dd * gmpy2.invert((q-1)//dd,(p-1)//dd) * (q-1) + dqm = pow(c,d,n)print libnum.n2s(m) RSA2 e，n，c，dp 1234567891011121314151617181920import gmpy2import libnume = n = c = dp = for x in range(1,e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gmpy2.invert(e, phin) m=gmpy2.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print libnum.n2s(m) RSA3 共模攻击 n，e1，e2，c1，c2 12345678910111213141516171819import gmpy2import libnumn=e1=e2=c1=c2=gcd, s, t = gmpy2.gcdext(e1, e2) #扩展欧几里得算法if s &lt; 0: s = -s c1 = gmpy2.invert(c1, n)if t &lt; 0: t = -t c2 = gmpy2.invert(c2, n)m = gmpy2.powmod(c1,s,n) * gmpy2.powmod(c2,t,n) % nprint libnum.n2s(m) RSA openssl的使用 rsatool 12345# openssl rsa -pubin -text -modulus -in warmup -in pub.key# pyhton rsatool.py -o private.pem -e '' -p '' -q ''# openssl rsautl -decrypt -in flag.enc -inkey private.pem RSAROLL 给出多个密文，逐一解密12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import gmpy2n = 920139713q = 18443p = 49891e = 19d = int(gmpy2.invert(e , (p-1) * (q-1))) c = '''70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148'''falg = ''for i in c.split('\\n'): falg += chr(pow(int(i),d,n))print falg Dangerous RSA 低加密指数攻击（e=3） 123456789import gmpy2import libnumc =n = e = 3m = gmpy2.iroot(c,3)[0]print libnum.n2s(m) rsa2 低解密指数攻击（e非常大）rsa-wiener-attack1234567891011121314151617181920212223242526272829303132import gmpy2import hashlibimport ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratordef hack_RSA(e,n): # Finds d knowing(e,n) # applying the Wiener continued fraction attack frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: # check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer discr = s*s - 4*n if(discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(\"Hacked!\") return d n =e = d = hack_RSA(e,n)flag = \"flag&#123;\" + hashlib.md5(hex(d)).hexdigest() + \"&#125;\"print flag RSA5题目给出了20对n，c 先将20个n两两取最大公因数，即可得到p（q），然后选取得到这个最大公因数的两个n中的其中一个，即可得到另一个素数 123456789list=[n,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19]for i in range(len(list)): for j in range(i+1,len(list)): print i,j try: print (gmpy2.gcd(list[i],list[j])) except: print \"error \",i continue 我这选的是n4，q=n4/p 1234567p=q=n4/pe = 65537phi = (p-1)*(q-1)d = gmpy2.invert(e, phi)nn = p * qprint libnum.n2s(pow(c4,d,nn)) SameMod 共模攻击 脚本跟RSA3相同，但解出的m需要用ASCII码解123456789101112string = str(m)flag=''i=0j=1while i &lt; len(string): if int(string[i:i+j]) &gt;= 33 and int(string[i:i+j]) &lt;=126: flag+=chr(int(string[i:i+j])) i=i+j j=1 else: j+=1print(flag) RSA4 中国剩余定理 使用中国剩余定理求解，但之前需做些转换，题目给出的n和c是5进制的求出m之后转换出错，估计不是直接模的n，然后猜测e=3，开个根即可 1234567891011121314151617181920212223242526272829import gmpy2import libnumn1= c1= n2= c2= n3= c3= ms=[n1,n2,n3]cs=[c1,c2,c3]for i in range(len(ms)): ms[i]=int(str(ms[i]),5) cs[i]=int(str(cs[i]),5)def CRT(bs,ms): m = reduce(lambda x,y: x*y, ms) re = 0 for i in range(len(ms)): M = m / ms[i] gcd, n1, M1 = gmpy2.gcdext(ms[i], M)# ms[i]*n1 + M*M1 = 1 re += bs[i] * M * M1 return re % mm = CRT(cs,ms)mm = gmpy2.iroot(m,3)[0]print libnum.n2s(mm) RSA&amp;what 共模攻击 base64隐写 123456789101112131415161718192021222324import gmpy2import libnumn=e1=e2=cc1=cc2=def samemod(c1,c2): gcd, s, t = gmpy2.gcdext(e1, e2) if s &lt; 0: s = -s c1 = gmpy2.invert(c1, n) if t &lt; 0: t = -t c2 = gmpy2.invert(c2, n) m = gmpy2.powmod(c1,s,n) * gmpy2.powmod(c2,t,n) % n return mfor i in range(len(cc1)): print libnum.n2s(samemod(cc1[i],cc2[i])) 在将结果写进txt时，注意将base64合并一下，确保每行结尾为’=’base64隐写脚本 123456789101112131415161718192021222324252627282930313233343536#https://www.jianshu.com/p/48fe4dd3e5cedef get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('0.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '') diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == '__main__': solve_stego() 坏蛋是雷宾 Rabin算法 原理详见：https://wiki.x10sec.org/crypto/asymmetric/rsa/rsa_e_attack/1234567891011121314151617181920212223242526272829from gmpy2 import *import hashlibn=523798549p=10663q=49123e=2c=162853095inv_p = invert(p, q)inv_q = invert(q, p)mp = pow(c, (p + 1) / 4, p)mq = pow(c, (q + 1) / 4, q)a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)for i in (a, b, c, d): print(bin(i)[2:])#10010011100100100101010110001 m='10010011100100100101010'mc=str(int(m,2))md=hashlib.md5()md.update(mc.encode(\"utf8\"))flag = md.hexdigest()print(\"flag&#123;\"+str(flag)+'&#125;')","categories":[],"tags":[{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://yoursite.com/tags/CRYPTO/"},{"name":"BUU","slug":"BUU","permalink":"http://yoursite.com/tags/BUU/"},{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"}]},{"title":"MRCTF2020 Misc&Crypto部分Write Up","slug":"MRCTF2020-Misc-Crypto部分WriteUp","date":"2020-04-30T13:26:39.000Z","updated":"2020-05-31T09:56:05.752Z","comments":true,"path":"2020/04/30/MRCTF2020-Misc-Crypto部分WriteUp/","link":"","permalink":"http://yoursite.com/2020/04/30/MRCTF2020-Misc-Crypto%E9%83%A8%E5%88%86WriteUp/","excerpt":"还是太菜，害 复现：https://buuoj.cn/challenges","text":"还是太菜，害 复现：https://buuoj.cn/challenges Crypto天干地支+甲子查一下每一个代表的数字，然后加上60（甲子），ASCII转一下就ok 123a= [11, 51,51,40,46,51,38] print ''.join(chr(i+60) for i in a) MRCTF{Goodjob} keyboard键盘密码，手机9键走起 解出来是mobilephond，改一下mobilephone MRCTF{mobilephone} 古典密码知多少蓝色：猪圈密码，黄色：圣武士堂密码，黑色：银河密码 解出来：FGCPFLIRTUASYON 然后栅栏一下：FLAGISCRYPTOFUN 最后MRCTF{CRYPTOFUN} vigenere直接在线解密：https://www.guballa.de/vigenere-solver 12345678910111213141516171819a declaration of the independence of cyberspaceby john perry barlow governments of the industrial world, you weary giants of flesh and steel, i come from cyberspace, the new home of mind. on behalf of the future, i ask you of the past to leave us alone. you are not welcome among us. you have no sovereignty where we gather.we have no elected government, nor are we likely to have one, so i address you with no greater authority than that with which liberty itself always speaks. i declare the global social space we are building to be naturally independent of the tyrannies you seek to impose on us. you have no moral right to rule us nor do you possess any methods of enforcement we have true reason to fear.governments derive their just powers from the consent of the governed. you have neither solicited nor received ours. we did not invite you. you do not know us, nor do you know our world. cyberspace does not lie within your borders. do not think that you can build it, as though it were a public construction project. you cannot. it is an act of nature and it grows itself through our collective actions.you have not engaged in our great and gathering conversation, nor did you create the wealth of our marketplaces. you do not know our culture, our ethics, or the unwritten codes that already provide our society more order than could be obtained by any of your impositions.you claim there are problems among us that you need to solve. you use this claim as an excuse to invade our precincts. many of these problems don&#39;t exist. where there are real conflicts, where there are wrongs, we will identify them and address them by our means. we are forming our own social contract. this governance will arise according to the conditions of our world, not yours. our world is different.cyberspace consists of transactions, relationships, and thought itself, arrayed like a standing wave in the web of our communications. ours is a world that is both everywhere and nowhere, but it is not where bodies live.we are creating a world that all may enter without privilege or prejudice accorded by race, economic power, military force, or station of birth.we are creating a world where anyone, anywhere may express his or her beliefs, no matter how singular, without fear of being coerced into silence or conformity.your legal concepts of property, expression, identity, movement, and context do not apply to us. they are all based on matter, and there is no matter here.our identities have no bodies, so, unlike you, we cannot obtain order by physical coercion. we believe that from ethics, enlightened self-interest, and the commonweal, our governance will emerge. our identities may be distributed across many of your jurisdictions. the only law that all our constituent cultures would generally recognize is the golden rule. we hope we will be able to build our particular solutions on that basis. but we cannot accept the solutions you are attempting to impose.in the united states, you have today created a law, the telecommunications reform act, which repudiates your own constitution and insults the dreams of jefferson, washington, mill, madison, detoqueville, and brandeis. these dreams must now be born anew in us.you are terrified of your own children, since they are natives in a world where you will always be immigrants. because you fear them, you entrust your bureaucracies with the parental responsibilities you are too cowardly to confront yourselves. in our world, all the sentiments and expressions of humanity, from the debasing to the angelic, are parts of a seamless whole, the global conversation of bits. we cannot separate the air that chokes from the air upon which wings beat.in china, germany, france, russia, singapore, italy and the united states, you are trying to ward off the virus of liberty by erecting guard posts at the frontiers of cyberspace. these may keep out the contagion for a small time, but they will not work in a world that will soon be blanketed in bit-bearing media.your increasingly obsolete information industries would perpetuate themselves by proposing laws, in america and elsewhere, that claim to own speech itself throughout the world. these laws would declare ideas to be another industrial product, no more noble than pig iron. in our world, whatever the human mind may create can be reproduced and distributed infinitely at no cost. the global conveyance of thought no longer requires your factories to accomplish.these increasingly hostile and colonial measures place us in the same position as those previous lovers of freedom and self-determination who had to reject the authorities of distant, uninformed powers. we must declare our virtual selves immune to your sovereignty, even as we continue to consent to your rule over our bodies. we will spread ourselves across the planet so that no one can arrest our thoughts.we will create a civilization of the mind in cyberspace. may it be more humane and fair than the world your governments have made before.flag is mrctf vigenere crypto crack man, please add underscore and curly braces. flag:MRCTF{vigenere_crypto_crack_man} babyRSA看了一下源代码，找到p和q就行，然后先看p 12345678910111213def gen_p(): P = [0 for i in range(17)] P[0] = getPrime(128) for i in range(1, 17): P[i] = sympy.nextprime(P[i-1]) print(\"P_p :\", P[9]) n = 1 for i in range(17): n *= P[i] p = getPrime(1024) factor = pow(p, base, n) print(\"P_factor :\", factor) return sympy.nextprime(p) 因为已经给出了P[9]，而且使用的是nextprime()，即可以将数组测试出来，这样就得到了这里面的n，从而得到后面需要的p 然后看q 123456789def gen_q(): sub_Q = getPrime(1024) Q_1 = getPrime(1024) Q_2 = getPrime(1024) Q = sub_Q ** Q_2 % Q_1 print(\"Q_1: \", Q_1) print(\"Q_2: \", Q_2) print(\"sub_Q: \", sub_Q) return sympy.nextprime(Q) 直接使用pow(sub_Q,Q-2,Q_1)得到Q，然后nextprime得到q脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import libnumimport sympyimport gmpy2from Crypto.Util.number import getPrimee = 65537factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839p = [0 for i in range(17)]p[0]=206027926847308612719677572554991142909p[1]=206027926847308612719677572554991142911p[2]=206027926847308612719677572554991142977p[3]=206027926847308612719677572554991143071p[4]=206027926847308612719677572554991143103p[5]=206027926847308612719677572554991143121p[6]=206027926847308612719677572554991143133p[7]=206027926847308612719677572554991143317p[8]=206027926847308612719677572554991143401p[9]=206027926847308612719677572554991143421for i in range(10,17): p[i]=sympy.nextprime(p[i-1])n = 1for i in range(17): x= n*p[i] n=xphi=1for i in range(0,17): phi *=p[i]-1#print n#print sympy.nextprime(n)d1 = gmpy2.invert(e,phi)p = pow(factor, d1, n)p = sympy.nextprime(p)print pQ_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651Q = pow(sub_Q, Q_2, Q_1)q = sympy.nextprime(Q)print qc = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832ph = (p-1)*(q-1)d = gmpy2.invert(e, ph)m = pow(c, d, p*q)print libnum.n2s(m)# flag：MRCTF&#123;sti11_@_b@by_qu3st10n&#125; Easy_RSA跟上一题相似，也是求p和q的 先看p： 123456789101112def gen_p(): p = getPrime(1024) q = getPrime(1024) assert (p &lt; q) n = p * q print(\"P_n = \", n) F_n = (p - 1) * (q - 1) print(\"P_F_n = \", F_n) factor2 = 2021 * p + 2020 * q if factor2 &lt; 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) 可以知道这里已知的数有n = p q和φ(n) = (p-1) (q-1) ，这里就可以使用二分法来计算 然后是q： 12345678910111213141516def gen_q(): p = getPrime(1024) q = getPrime(1024) assert (p &lt; q) n = p * q print(\"Q_n = \", n) e = getRandomNBitInteger(53) F_n = (p - 1) * (q - 1) while gcd(e, F_n) != 1: e = getRandomNBitInteger(53) d = invert(e, F_n) print(\"Q_E_D = \", e * d) factor2 = 2021 * p - 2020 * q if factor2 &lt; 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) 相当于是已知e，d，n，借鉴了大佬的博客 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import sympyimport libnumfrom gmpy2 import *def get_P(): # P_n = p * q P_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693 # P_F_n = p*q - (p+q) + 1 P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740 # P_Q = p+q P_Q = P_n - P_F_n + 1 #print P_Q l=P_Q/2 r=P_Q while l&lt;r: p=(l+r)/2 y=p*(P_Q-p) if y==P_n: #print p break if y&gt;P_n: #print 'y&gt;P_n' l=p else: #print 'y&lt;P_n' r=p #print 'done' q=P_Q-p #print q if p&gt;q: p,q=q,p factor2 = 2021 * p + 2020 * q if factor2 &lt; 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) def get_Q(): # Q_n = p * q Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947 # Q_E_D = e * d Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201 f, s, tem = Q_E_D-1, 0, 1 while f % 2 == 0: f = f // 2 s += 1 i, a, t = s, 2, f b = pow(a, t, Q_n) while b == 1: a = sympy.nextprime(a) b = pow(a, t, Q_n) while i != 1: c = pow(b, 2, Q_n) if c != 1: b = c i -= 1 else: break if b == Q_n-1: a = sympy.nextprime(a) b = pow(a, t, Q_n) while b == 1: a = sympy.nextprime(a) b = pow(a, t, Q_n) p = gcd(b-1, Q_n) q = Q_n//p factor2 = 2021 * p - 2020 * q if factor2 &lt; 0: factor2 = (-1) * factor2 return sympy.nextprime(factor2) p = get_P()print pq = get_Q()print qc = 40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021e = 65537n = p * qphi = (p-1) * (q-1)d = invert(e, phi)m = pow(c,d,n)print libnum.n2s(m)# flag：MRCTF&#123;Ju3t_@_31mp13_que3t10n&#125; Misc你能看懂音符吗打开压缩包，发现一文档，不知道把文档里的内容藏哪去了，直接解压文档，在document.xml中找到音符 在线网站解密 flag：MRCTF{thEse_n0tes_ArE_am@zing~} ezmisc图片显示问题，估计改了高，爆破一下，修改得到flag1234567891011121314151617181920212223import zlibimport structfilename = 'flag.png'with open(filename, 'rb') as f: all_b = f.read() crc32key = int(all_b[29:33].hex(),16) data = bytearray(all_b[12:29]) n = 4095 #理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了 for w in range(n): #高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w)) #q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(\"宽为：\",end=\"\") print(width) print(\"高为：\",end=\"\") print(height) exit(0) flag:MRCTF{1ts_vEryyyyyy_ez!} CyberPunk将系统时间改成2020/09/17就行了 flag:MRCTF{We1cOm3_70_cyber_security} 不眠之夜直接拼图 flag：MRCTF{Why_4re_U_5o_ShuL1an??} (听说nb的大佬都是直接montage，但是我这种菜鸟不会用啊啊啊) 千层套路直接上解压脚本： 1234567891011121314151617import zipfile,os def unzip(path,zfile): file_path=path+os.sep+zfile desdir=path print(desdir) srcfile=zipfile.ZipFile(file_path) for filename in srcfile.namelist(): srcfile.extract(filename,desdir,pwd= bytes(zfile.split(\".\")[0],\"utf8\")) if filename.endswith('.zip'): # if zipfile.is_zipfile(filename): path=desdir zfile=filename unzip(path,zfile)path=\"C:\\\\Users\\\\Admin\\\\Downloads\\\\[MRCTF2020]千层套路\"zfile=\"0573.zip\"unzip(path,zfile) 然后得到rgb 123456789101112131415from PIL import Imagex=200y=200im=Image.new(\"RGB\",(x,y))file=open('qr.txt')for i in range(0,x): for j in range(0,y): line=file.readline() rgb=line.replace(\"\\n\",\"\").replace(\"(\",\"\").replace(\")\",\"\").split(\", \") #print rgb if(rgb[0]==''): continue im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.show() 得到二维码，扫码得flag：MRCTF{ta01uyout1nreet1n0usandtimes} Unravel!!首先是Look_at_the_file_ending.wav文件，直接010打开，可以看到有一串字符串 key=U2FsdGVkX1/nSQN+hoHL8OwV9iJB/mSdKk5dmusulz4= 然后看看JM.png这张图片，binwalk，foremost一下，得到压缩包，解压得到aes.png图片，上面写着“Tokyo” 估计是aes加密，找个网站在线解密一下https://www.sojson.com/encrypt_aes.html 又得到一串字符串CCGandGulu 最后看看Ending.wav，用SilentEye打开，输入密码，得到flag:MRCTF{Th1s_is_the_3nd1n9} Hello_ misc拿到图片，binwalk,foremost直接走起，得到压缩包，然后用Stegsolve看看图片，将Red的0通道保存得到压缩包密码：!@#$%67*()-+ 压缩包解压后，打开文件是一大堆63,127,191,255，TTL隐写 1234567891011121314151617181920212223fp = open('out.txt','r')a = fp.readlines()p = []for i in a: p.append(int(i))s = ''for i in p: if i == 63: a = '00' elif i == 127: a = '01' elif i == 191: a = '10' elif i == 255: a = '11' s += aimport binasciiflag = ''for i in range(0,len(s),8): flag += chr(int(s[i:i+8],2))print (flag)# rar-passwd:0ac1fe6b77be5dbe 得到了rar的密码：0ac1fe6b77be5dbe rar解压后发现文档中的5串base64编码，解码之后全是0和1 然后仔细一看，将1替换成空格，然后缩小至最小（sublime Text），就能看出flag了 flag:MRCTF{He1Lo_mi5c~} (居然是5。。。) pyFlag给了3张图片，010打开发现文件尾都有点数据，foremost分不出来，仔细看了看，将三个数据合并成一个后，解压得到一个txt，里面是flag的base套娃，直接一个一个的试 解码顺序：base85-&gt;base16-&gt;base32-&gt;base16-&gt;base64 flag:MRCTF{Y0u_Are_4_p3rFect_dec0der} 寻找xxx电话音，使用dtmf2num.exe，得到电话号码18684221609 发送到公众号，得到flag:MRCTF{Oh!!!_Y0u_f1nd_my_secret} A Signal From ISSSSTV无线电相关知识，将图片转换成声音，使用MMSSTV即可 flag:merak{r3ce1ved_4n_img} 小O的考研复试简单数学题 123456flag=0for i in range(0,19260817): flag=(flag*10+2)%1000000007print flag# 577302567 flag:MRCTF{577302567}","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://yoursite.com/tags/MISC/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://yoursite.com/tags/CRYPTO/"}]},{"title":"BJDCTF2020 Misc&Crypto部分WriteUp","slug":"BJDCTF2020-Misc-Crypto部分WriteUp","date":"2020-03-14T13:33:01.000Z","updated":"2020-05-31T12:28:50.289Z","comments":true,"path":"2020/03/14/BJDCTF2020-Misc-Crypto部分WriteUp/","link":"","permalink":"http://yoursite.com/2020/03/14/BJDCTF2020-Misc-Crypto%E9%83%A8%E5%88%86WriteUp/","excerpt":"复现平台：https://buuoj.cn/challenges","text":"复现平台：https://buuoj.cn/challenges Crypto这是base？？base编码原理的实现，百度了一下，找到个脚本，改一下table即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt;const char* base64_table = \"JKLMNOxyUVzABCDEFGH789PQIabcdefghijklmWXYZ0123456RSTnopqrstuvw+/=\"; /* base64编码表 */static int num_strchr(const char* str, char c)&#123; const char* p = strchr(str, c); if (NULL == p) &#123; return -1; &#125; return p - str;&#125;uint32_t base64_get_dest_len(uint32_t src_len)&#123; return 4 * ((src_len + 2) / 3);&#125;uint32_t src_get_dest_len(uint32_t base64_len)&#123; return base64_len / 4 * 3 - 2;&#125;int base64_encode(const char* src_str, uint32_t src_len, char* dest_str, uint32_t dest_len)&#123; uint32_t i, j, len; len = base64_get_dest_len(src_len); if (dest_len &lt; len) &#123;/* 空间不足 */ return -1; &#125; for (i = 0; i &lt; src_len / 3; i++) &#123; *dest_str++ = base64_table[(src_str[0] &gt;&gt; 2) &amp; 0x3f]; /* 取第一字符前6bit */ *dest_str++ = base64_table[((src_str[0] &lt;&lt; 4) &amp; 0x30) | ((src_str[1] &gt;&gt; 4) &amp; 0x0f)]; /* 第一字符的后2bit与第二字符的前4位进行合并 */ *dest_str++ = base64_table[((src_str[1] &lt;&lt; 2) &amp; 0x3c) | ((src_str[2] &gt;&gt; 6) &amp; 0x03)]; /* 将第二字符的后4bit与第三字符的前2bit组合并 */ *dest_str++ = base64_table[src_str[2] &amp; 0x3f]; /* 取第三字符的后6bit */ src_str += 3; &#125; /* 非3的整数倍补“=” */ if ((src_len % 3) == 1) &#123; *dest_str++ = base64_table[(src_str[0] &gt;&gt; 2) &amp; 0x3f]; *dest_str++ = base64_table[((src_str[0] &lt;&lt; 4) &amp; 0x30) | ((src_str[1] &gt;&gt; 4) &amp; 0x0f)]; *dest_str++ = '='; *dest_str++ = '='; &#125; else if ((src_len % 3) == 2) &#123; *dest_str++ = base64_table[(src_str[0] &gt;&gt; 2) &amp; 0x3f]; *dest_str++ = base64_table[((src_str[0] &lt;&lt; 4) &amp; 0x30) | ((src_str[1] &gt;&gt; 4) &amp; 0x0f)]; *dest_str++ = base64_table[(src_str[j + 1] &lt;&lt; 2) &amp; 0x3c]; *dest_str++ = '='; &#125; *dest_str = '\\0'; return 0;&#125;int base64_decode(const char* src_str, uint32_t src_len, char* dest_str, uint32_t dest_len)&#123; uint32_t i = 0; char buf[4] = &#123; 0 &#125;; if (dest_len &lt; src_get_dest_len(src_len)) &#123; return -1; &#125; for (; (src_str[i] != '\\0') &amp;&amp; (i &lt; src_len); i += 4) &#123; /* 四个码译成三个字符 */ buf[0] = num_strchr(base64_table, src_str[i]); buf[1] = num_strchr(base64_table, src_str[i + 1]); *dest_str++ = ((buf[0] &lt;&lt; 2) &amp; 0xfc) | ((buf[1] &gt;&gt; 4) &amp; 0x03); if (src_str[i + 2] == '=') &#123; break; &#125; buf[2] = num_strchr(base64_table, src_str[i + 2]); *dest_str++ = ((buf[1] &lt;&lt; 4) &amp; 0xf0) | ((buf[2] &gt;&gt; 2) &amp; 0x0f); if (src_str[i + 3] == '=') &#123; break; &#125; buf[3] = num_strchr(base64_table, src_str[i + 3]); *dest_str++ = ((buf[2] &lt;&lt; 6) &amp; 0xc0) | (buf[3] &amp; 0x3f); &#125; *dest_str = '\\0'; return 0;&#125;int main(int argc, char** argv)&#123; char* buf = NULL; uint32_t dest_len, src_len; if (argc &lt; 3) return -1; if (strcmp(argv[1], \"decode\") == 0) &#123; src_len = strlen(argv[2]); dest_len = src_get_dest_len(src_len); buf = (char*)malloc(dest_len); if (buf == NULL) return -1; base64_decode(argv[2], src_len, buf, dest_len); printf(\"base64 str:%s\\n\", argv[2]); printf(\"base64_decode str:%s\\n\", buf); &#125; else if (strcmp(argv[1], \"encode\") == 0) &#123; src_len = strlen(argv[2]); dest_len = base64_get_dest_len(src_len); buf = (char*)malloc(dest_len); if (buf == NULL) return -1; base64_encode(argv[2], src_len, buf, dest_len); printf(\"src str:%s\\n\", argv[2]); printf(\"base64_encode str:%s\\n\", buf); &#125; free(buf); buf = NULL; return 0;&#125; 1234root@Kali:~# gcc 0.croot@Kali:~# ./a.out decode FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKwbase64 str:FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKwbase64_decode str:BJD&#123;D0_Y0u_kNoW_Th1s_b4se_map&#125; signinhex编码 BJD{We1c0me_t4_BJDCTF} rsa_outputRSA共模攻击 123456789101112131415161718import gmpy2import libnumn= 21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111e1= 2767e2= 3659c1= 20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599c2= 11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227gcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0: s = -s c1 = gmpy2.invert(c1, n)if t &lt; 0: t = -t c2 = gmpy2.invert(c2, n)m = gmpy2.powmod(c1,s,n) * gmpy2.powmod(c2,t,n) % nprint libnum.n2s(m) RSAn1和n2共用一个q，可以先求最大公约数求出q，然后求出p，然后通过m（或者pow(294,e,n)）可以求出e，就把RSA的所有参数求出来了 123456789101112131415161718192021222324252627282930import libnumimport gmpy2c1 = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120n1 = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037c3 = 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018c2 = 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721n2 = 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047#q = gmpy2.gcd(n1, n2)#print q#p1 = n1 / q#p2 = n2 / q#print p1#print p2q = 99855353761764939308265951492116976798674681282941462516956577712943717850048051273358745095906207085170915794187749954588685850452162165059831749303473106541930948723000882713453679904525655327168665295207423257922666721077747911860159181041422993030618385436504858943615630219459262419715816361781062898911p1 = 135283423427545651023916134156519717109709399113553907832988770259402226695880524199087896377303631866790192008529658716376684328032075836094156150811025163336681163420875451747389868549203081743561907379260240665153166927504059379076555558704275659133135906827306189040804323574468819553401905127999523676067p2 = 128247614380441198621646495410948309946997239795951661931273072927374035259759992149357909896141726187046548986417994702167046344214464500647935997258628531837792334712721963467008407166687868929005971168361860024531036817205076054969304421022680304986295959208344157424943500032828301016675631415023886775977#for e in range(0,100000):# if pow(294, e, n1) == c3:# print e# breake = 52361phi = (p1 - 1)*(q - 1)d = gmpy2.invert(e, phi)m = pow(c1, d, n1)print libnum.n2s(m) flag: BJD{p_is_common_divisor} easyrsa实际上z=p^2+q^2 12345678910111213import libnumimport gmpy2e = 65537c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441p_and_q = gmpy2.iroot(z + 2*n,2)[0]phi = n - p_and_q + 1d = gmpy2.invert(e, phi)m = pow(c, d, n)print libnum.n2s(m) flag:BJD{Advanced_mathematics_is_too_hard!!!} Polybius棋盘密码，特点：密文长度是明文长度的两倍 密文中只出现了aeiou，解密不对，需要爆破顺序，即5！个,不太会写脚本（菜。。。） 官方wp： 1234567891011121314151617181920import itertoolskey = []cipher = \"ouauuuoooeeaaiaeauieuooeeiea\"for i in itertools.permutations('aeiou', 5): key.append(''.join(i))for each in key: temp_cipher = \"\" result = \"\" for temp in cipher: temp_cipher += str(each.index(temp)) #这里其实是将字母的表换成数字的表以便后续计算 for i in range(0,len(temp_cipher),2): current_ascii = int(temp_cipher[i])*5+int(temp_cipher[i+1])+97 #因为棋盘密码是采用两位一起表示一个字母 if current_ascii&gt;ord('i'): current_ascii+=1 result += chr(current_ascii) if \"flag\" in result: print(each,result) 长度14，猜测flag就是flagispolybius12uoaei flagispolybiusuoaie flagkxoplubkyx BJD{flagispolybius} 编码与调制曼彻斯特编码，学习了学习了。。。 123456789msg=0x2559659965656a9a65656996696965a6695669a9695a699569666a5a6a6569666a59695a69aa696569666aa6s=bin(msg)[2:]r=\"\"for i in range(len(s)/2): if s[i*2:i*2+2] == '10': r += '1' else: r += '0'print(hex(int(r,2))[2:-1].decode('hex')) flag:BJD{DifManchestercode} 伏羲六十四卦这套娃也套得太多了吧。。。 参考：https://github.com/BjdsecCA/BJDCTF2020_January 1234567891011121314151617181920212223242526272829303132import base64from binascii import a2b_hexenc='升随临损巽睽颐萃小过讼艮颐小过震蛊屯未济中孚艮困恒晋升损蛊萃蛊未济巽解艮贲未济观豫损蛊晋噬嗑晋旅解大畜困未济随蒙升解睽未济井困未济旅萃未济震蒙未济师涣归妹大有'mydisc=&#123;'坤': '000000', '剥': '000001', '比': '000010', '观': '000011', '豫': '000100', '晋': '000101', '萃': '000110', '否': '000111', '谦': '001000', '艮': '001001', '蹇': '001010', '渐': '001011', '小过': '001100', '旅': '001101', '咸': '001110', '遁': '001111', '师': '010000', '蒙': '010001', '坎': '010010', '涣': '010011', '解': '010100', '未济': '010101', '困': '010110', '讼': '010111', '升': '011000', '蛊': '011001', '井': '011010', '巽': '011011', '恒': '011100', '鼎': '011101', '大过': '011110', '姤': '011111', '复': '100000', '颐': '100001', '屯': '100010', '益': '100011', '震': '100100', '噬嗑': '100101', '随': '100110', '无妄': '100111', '明夷': '101000', '贲': '101001', '既济': '101010', '家人': '101011', '丰': '101100', '离': '101101', '革': '101110', '同人': '101111', '临': '110000', '损': '110001', '节': '110010', '中孚': '110011', '归妹': '110100', '睽': '110101', '兑': '110110', '履': '110111', '泰': '111000', '大畜': '111001', '需': '111010', '小畜': '111011', '大壮': '111100', '大有': '111101', '夬': '111110', '乾': '111111'&#125;keys=['坤', '剥', '比', '观', '豫', '晋', '萃', '否', '谦', '艮', '蹇', '渐', '小过', '旅', '咸', '遁', '师', '蒙', '坎', '涣', '解', '未济', '困', '讼', '升', '蛊', '井', '巽', '恒', '鼎', '大过', '姤', '复', '颐', '屯', '益', '震', '噬嗑', '随', '无妄', '明夷', '贲', '既济', '家人', '丰', '离', '革', '同人', '临', '损', '节', '中孚', '归妹', '睽', '兑', '履', '泰', '大畜', '需', '小畜', '大壮', '大有', '夬', '乾']m=encfor each in keys: m=m.replace(each,mydisc[each])print(m) m1 = 0b011000100110110000110001011011110101100001000110001100010111001001100001001100100100011001100010010101110011001001010110011100000101011000110001011001000110011001010101011011010100001001101001010101000011000100110001011001000101100101000101001101010100111001010110010101100110010001011000010100110101010101011010010110010101001101000110010101100100010001010101010000010011110100111101print (str(hex(m1)))print (a2b_hex(str(hex(m1)[2::1])))m2 = 'bl1oXF1ra2FbW2VpV1dfUmBiT11dYE5NVVdXSUZYSFVDUA=='print (base64.b64decode(m2))m3 = 'n]h\\\\]kka[[eiWW_R`bO]]`NMUWWIFXHUCP'm4=''offset=5for i in range(len(m3)): m4+=chr(ord(m3[i])+offset+i)print(m4)m5 = 'scodfuvmhityhirfuxfuvziiruvigzkyhv'b=7for i in (1,9,21,15,3,7,23,19,11,5,17,25): flag = '' for k in m5: flag += chr(i*((ord(k)-ord('a'))-b)%26+ord('a')) print(i,':',flag) output: 12345678910111213141516170110001001101100001100010110111101011000010001100011000101110010011000010011001001000110011000100101011100110010010101100111000001010110001100010110010001100110010101010110110101000010011010010101010000110001001100010110010001011001010001010011010101001110010101100101011001100100010110000101001101010101010110100101100101010011010001100101011001000100010101010100000100111101001111010x626c316f58463172613246625732567056316466556d4269543131645945354e5656645853555a595346564455413d3db'bl1oXF1ra2FbW2VpV1dfUmBiT11dYE5NVVdXSUZYSFVDUA=='b'n]h\\\\]kka[[eiWW_R`bO]]`NMUWWIFXHUCP'scodfuvmhityhirfuxfuvziiruvigzkyhv1 : lvhwynofabmrabkynqynosbbknobzsdrao9 : vhlqinwtajexajminoinwgjjmnwjrgbxaw21 : xzruknibavstavcknykniovvcnivfoltai15 : jdbswncxapyvapuwngwnckppuncplktvac3 : hlvounqpadkzadeunwunqcddenqdxcjzaq7 : zrxymnujahgpahsmnimnuwhhsnuhtwvpau23 : tpfmgnklaxqbaxwgnegnkyxxwnkxdyrbak19 : bjdcongratulationsongettingtheflag11 : rxzienydalcfalgenuenyqllgnylpqhfay5 : dbjgqnszafihafyqncqnsmffynsfvmphas17 : ftpksneharwdarosnmsneurronerjuzdae25 : pftecnmvazojazqcnkcnmizzqnmzbixjam flag:BJD{bjdcongratulationsongettingtheflag} Misc认真你就输了解压文档，找一下就找到了flag，charts文件夹下flag：flag{M9eVfi2Pcs&#35;} 你猜我是个啥打开压缩包文件报错，16进制看一下，是个png，改后缀，是个二维码，扫描说flag不在这。。。 继续16进制看看，文件底部找到flag:flag{i_am_fl@g} 藏藏藏给了一张jpg图片，binwalk发现压缩包，foremost解压得到一个文档，打开扫码得到flag:flag{you are the best!} just_a_rar4位数密码爆破，得到：2016，解压得到图片，16进制源码得到flag:flag{Wadf_123} 一叶障目因为我使用的是honeyview查看图片，显示失败，多半是改了png图片的高，010打开，将第二行的01 4C改成03 4C保存，再打开就得到flag:flag{66666} 纳尼gif文件打不开，多半是16进制源码出问题了，打开看到少了gif的文件头，添加上47 49 46 38后保存，打开看到字符串，记录下来Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0= base64:CTF{wang_bao_qiang_is_sad} 鸡你太美给了两张gif，一个打不开，直接010,看到，第二张少了文件头，加上之后得到flag:flag{zhi_yin_you_are_beautiful}","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://yoursite.com/tags/MISC/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://yoursite.com/tags/CRYPTO/"},{"name":"BUU","slug":"BUU","permalink":"http://yoursite.com/tags/BUU/"}]},{"title":"CTF中RSA的常见套路","slug":"CTF中RSA的常见套路","date":"2020-02-22T06:20:12.000Z","updated":"2020-06-01T13:01:19.314Z","comments":true,"path":"2020/02/22/CTF中RSA的常见套路/","link":"","permalink":"http://yoursite.com/2020/02/22/CTF%E4%B8%ADRSA%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/","excerpt":"当时学习RSA的时候感觉挺简单的，但一到做题时，就发现还有很多地方没有理解透，这里记录一下CTF中RSA的常见套路，参考来源：https://wiki.x10sec.org/crypto/introduction/https://err0rzz.github.io/2017/11/14/CTF中RSA套路/index.html这里仅记录一些代码，具体解法还请参考：https://www.anquanke.com/post/id/84632需要注意：关于gmpy2库的使用，可以参考https://www.cnblogs.com/pcat/p/5746821.html","text":"当时学习RSA的时候感觉挺简单的，但一到做题时，就发现还有很多地方没有理解透，这里记录一下CTF中RSA的常见套路，参考来源：https://wiki.x10sec.org/crypto/introduction/https://err0rzz.github.io/2017/11/14/CTF中RSA套路/index.html这里仅记录一些代码，具体解法还请参考：https://www.anquanke.com/post/id/84632需要注意：关于gmpy2库的使用，可以参考https://www.cnblogs.com/pcat/p/5746821.html 数据提取一般来说，RSA都围绕着c,m,d,n,p,q这几个参数展开，但不会给出全部，给出其中几个来求解。数据的给出也有以下几种方式： txt文件：直接给出已知数据，分析求解 源文件：直接将加密的源文件给出，通过分析源代码，编写程序求解 pem文件：针对这类文件需要使用openssl来提取数据12openssl rsa -pubin -text -modulus -in warmup -in public.pemopenssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc pcap文件：针对这类文件可以使用wireshake follow一下。这种问题一般都是写了一个交互式crypto系统，可能产生多轮交互 ppc模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出 模数分解先说一说RSA中最简单最暴力的，直接分解n，一般给出的n不会太大 已知n求p，q 在线分解：http://www.factordb.com/通过在此类网站上查询n，如果可以分解或者之前分解成功过，那么可以直接得到p和q。此类问题一般是分值较小的题目，提取出n之后可以发现n的长度小于等于512bit，可以直接取分解n。如果大于512bit，建议在使用每个题目都用后面所说的方法去解题。 yafu分解：https://sourceforge.net/projects/yafu/下载解压后直接打开程序，输入factor(n)，n为要分解的数，即可 公约数分解n：一般这种是用于题目给出了两个及以上的n，可以使用这种方法来得到p和q，然后n1与n2的最大公因数就是p，再用n1或n2除以p就能得到q1或q2 123456789101112def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return ap = gcd(n1, n2)q1 = n1/pq2 = n2/p 或者直接使用gmpy2库12345import gmpy2p = gmpy2.gcd(n1, n2)q1 = n1/pq2 = n2/p 已知e，p，q求d一般e都是直接给出的，然后得到p和q之后，便可以求d12345678910111213141516171819def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % md = modinv(e,(p-1)*(q-1))#或者使用gmpy2import gmpy2d = gmpy2.invert(e,(p-1)*(q-1)) 已知c，d，n求m1pow(c, d, n) 低加密指数攻击e = 3时的小明文攻击识别：e=3时如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。如果明文的三次方虽然比n大，但是大不了多少，则可以爆破。123456i = 0 while 1: if(gmpy2.iroot(c+i*n, 3)[1]==1): print gmpy2.iroot(c+i*n, 3) break i = i + 1 低加密指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。这个识别起来比较简单，一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。（个人还没做到过） 低解密指数攻击识别：简单来说，就是e非常大GitHub上的开源攻击代码：https://github.com/pablocelayes/rsa-wiener-attack这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上：12import syssys.setrecursionlimit(10000000)1234567891011121314151617181920212223242526import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratordef hack_RSA(e,n): ''' Finds d knowing (e,n) applying the Wiener continued fraction attack ''' frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(\"Hacked!\") return dd = hack_RSA(e,n) 共模攻击识别：若干次加密，e不同，n相同，m相同。就可以在不分解n和求d的前提下，解出明文m。给出了c1，c2，e1，e2，n1234567891011import gmpy2gcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0: s = -s c1 = gmpy2.invert(c1, n)if t &lt; 0: t = -t c2 = gmpy2.invert(c2, n)m = gmpy2.powmod(c1,s,n) * gmpy2.powmod(c2,t,n) % n 已知dp，dq最开始看到dp和dq时还查了好久，不知道啥意思，推导参考：https://beiyuouo.github.io/beiyuouo.github.io/blog/ctf-buuctf/ 已知dp，dq，p，q，c其中 dp \\equiv d \\pmod {\\varphi(p)}， dq \\equiv d \\pmod {\\varphi(q)}使用中国剩余定理即可，但p-1与q-1不互质，推导如下： dd=gcd(p-1,q-1) \\\\ d=k_1{\\varphi(p)}+dp=k_2{\\varphi(q)}+dq \\\\ k_2{\\varphi(q)} \\equiv {dp - dq} \\pmod{\\varphi(p)} \\\\ k_2 \\frac {\\varphi(q)}{dd} \\equiv \\frac{dp-dq}{dd} \\pmod {\\frac{\\varphi(p)}{dd}} \\\\ k_2 = k' \\frac{\\varphi(p)}{dd} + \\frac{dp-dq}{dd} (\\frac{\\varphi(q)}{dd})^{-1}最后 d=k_2{\\varphi(q)}+dq=(k'\\frac{\\varphi(p)}{dd}+\\frac{pd-dq}{dd} ({\\frac{\\varphi(q)}{dd}})^{-1}){\\varphi(q)}+dq123456import gmpy2n = p*qphi = (p-1)*(q-1)dd = gmpy2.gcd(p-1, q-1)d=(dp-dq)//dd * gmyp2.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq 已知e，n，dp，cdp同上 e*dp \\equiv ed \\pmod{\\varphi(p)} \\\\ ed=k{\\varphi(p)}+e*dp \\\\ ed = (k{\\varphi(p)}+e*dp) \\equiv 1 \\pmod{\\varphi(n)} \\\\ k{\\varphi(p)}+e*dp=k'(p-1)(q-1)+1 \\\\ 移项得\\\\ (p-1)(k'(q-1)-k)+1=e*dp \\\\ \\because dp(k'(q-1)-k)=x然后枚举x就可以计算出p-1123456789101112131415import gmpy2for x in range(1,e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gmpy2.invert(e, phin) m=gmpy2.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print m 已知e，d，n123456789101112131415161718192021222324252627282930import gmpy2import sympy# n = p * qn =# e_d = e * de_d = f, s, tem = e_d-1, 0, 1while f % 2 == 0: f = f // 2 s += 1i, a, t = s, 2, fb = pow(a, t, n)while b == 1: a = sympy.nextprime(a) b = pow(a, t, n)while i != 1: c = pow(b, 2, n) if c != 1: b = c i -= 1 else: breakif b == n-1: a = sympy.nextprime(a) b = pow(a, t, n) while b == 1: a = sympy.nextprime(a) b = pow(a, t, n)p = gmpy2.gcd(b-1, n)q = n//p 已知n(pq)，(p-1)(q-1)利用二分法求p，q123456789101112131415161718192021# n = p * qn =# phi = (p- 1 ) * (q - 1)phi =c=n-phi+1 # p + ql=c/2r=cwhile l&lt;r: p=(l+r)/2 y=p*(c-p) if y==n: print p break if y&gt;n: l=p else: r=pq=c-pprint q 中国剩余定理123456789101112import gmpy2ms=[]cs=[]def CRT(bs,ms): m = reduce(lambda x,y: x*y, ms) re = 0 for i in range(len(ms)): M = m / ms[i] gcd, n1, M1 = gmpy2.gcdext(ms[i], M)# ms[i]*n1 + M*M1 = 1 re += bs[i] * M * M1 return re % mm = CRT(cs,ms)","categories":[],"tags":[{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://yoursite.com/tags/CRYPTO/"},{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"}]},{"title":"BUUCTF Crypto部分wp","slug":"BUUCTF-Crypto部分wp","date":"2020-02-21T11:13:49.000Z","updated":"2020-05-30T04:25:55.892Z","comments":true,"path":"2020/02/21/BUUCTF-Crypto部分wp/","link":"","permalink":"http://yoursite.com/2020/02/21/BUUCTF-Crypto%E9%83%A8%E5%88%86wp/","excerpt":"记录一些密码学简单的题目，仅供参考","text":"记录一些密码学简单的题目，仅供参考 1.MD5直接md5解密https://www.cmd5.com/ 2.看我回旋踢一看就是凯撒密码，直接凯撒解密http://www.nicetool.net/embed/caesar_decrypt.html 3.Url编码Url解密http://tool.chinaz.com/tools/urlencode.aspx 4.一眼就解密一眼就看出base64编码，解密http://ctf.ssleye.com/base64.html 5.摩丝摩斯密码http://www.ip138.com/mosi/ 6.变异凯撒既然是凯撒加密，就先看看密文：有小写字母，大写字母，”_”，”^”，还有数字，可能是按照ASCII码表移位的，’a’的ASCII值为97，’f’为102，a-&gt;f的ASCII值增加了5；’l’为108，f-&gt;l的ASCII值增加了6；’Z’为90，Z-&gt;a的ASCII值增加了7；之后的每次移位增加1，所以写个脚本 1234567s = \"afZ_r9VYfScOeO_UL^RWUc\"res =\"\"j = 5for i in s: res += chr(ord(i) + j) j += 1print(res)运行一下即得flag 7.Quoted-printableQuoted-printable编码http://ctf.ssleye.com/quoted.html 8.password弱密码，猜测flag为zs19900315 9.zip伪加密懒得写了，可以参考一下这篇文章https://blog.csdn.net/qq_26187985/article/details/83654197（还有更简单的，直接在Linux系统下提取文件，zip伪加密能够直接提取出来的） 10.RabbitRabbit密码https://www.sojson.com/encrypt_rabbit.html 11.丢失的MD5运行一遍程序就得到了flag，展示的是md5的爆破（后面的还原大师就可以用这个） 12.篱笆墙的影子篱笆-&gt;栅栏，栅栏密码https://www.qqxiuzi.cn/bianma/zhalanmima.php 13.Alice与Bob在线分解http://www.factordb.com/，然后再md5https://www.cmd5.com/ 14.传统知识+古典密码百度得到每一个年份代表的具体数字，然后“+甲子”就是指加60，之后得到88 90 83 68 77 70 76 90通过ASCII码查表之后得到XZSDMFLZ，在试一试栅栏和凯撒，发现先栅栏（XMZFSLDZ）后凯撒（SHUANGYU）得到flag 15.大帝的密码武器古罗马大帝-&gt;凯撒-&gt;凯撒密码，先解密FRPHEVGL，解出来security，移动14位，然后在用这个来加密ComeChina，不过要注意大小写 16.Windows系统密码Linux的shadow文件，把这几个都用md5查询一遍，发现密码是：a7fcb22a88038f35a8f39d503e7f0062，解出：good-luck 17.凯撒？替换？呵呵!替换密码，直接在线破解https://quipqiup.com/（在Clues处填MTHJ=flag） 18.信息化时代的步伐中文电码直接破解http://code.mcdvisa.com/ 19.old-fashion同样是替换密码，直接在线破解https://quipqiup.com/ ?l fog?vryoe?sg, e h?dhv?v?v?rl f??sao ?h e ?avsrb rc alfrb?ly dg ?s?fs ?l?vh rc ?ne?lvaiv eoa oa?nefab ??vs f??saovaiv, effrob?ly vr e oay?neo hghva?; the units may be single letters (the most common), pairs of letters, triplets of letters, mi?tures of the above, and so forth. The receiver deciphers the te?t by performing an inverse substitution. So the flag is n1_2hen-d3_hu1-mi-ma_a 20.robomunication仔细一听，像是摩斯密码，将’b’换成’.’，’p’换成’_’，得到 …. . .-.. .-.. —- .— …. .- - .. … - …. . -.- . -.— .. - .. … -… —- —- .—. -… . . .—.解密得到 HELLOWHATISTHEKEYITISBOOPBEEP 21.世上无难事词频分析https://quipqiup.com/ 22.萌萌哒的八戒猪圈密码http://ctf.ssleye.com/pigpen.html 23.权限获得第一步和之前的Windows系统密码一样的道理 24.异性相吸异或，直接上脚本123456789with open('密文.txt' )as a: a=a.read()with open('key.txt' )as b: b=b.read()d=''for i in range(0,len(b)): c=chr(ord(a[i])^ord(b[i])) d+=cprint(d) 25.还原大师就用之前丢失的md5中给出的脚本，换一下数据即可 26.Cipher本来没啥思路的，看到那句“公平的玩吧（密钥自己找）”，公平：fair，估计是playfair，密钥就猜是playfair，然后在线解密 http://rumkin.com/tools/cipher/playfair.php 27.这是什么用16进制编译器（winhex，010Editor）打开，可以看到一大堆括号，感叹号，复制下来，直接放在浏览器的命令行（console）中，得到flag（我记得有一大串FFFFFFF的文件是word文件，也可以直接把文件后缀名改成.doc，打开也能看到文本） 28.UnencodeUUencodehttp://ctf.ssleye.com/uu.html","categories":[],"tags":[{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://yoursite.com/tags/CRYPTO/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"BUUCTF MISC zip","slug":"BUUCTF-MISC-zip","date":"2020-02-16T05:53:15.000Z","updated":"2020-06-01T11:57:40.365Z","comments":true,"path":"2020/02/16/BUUCTF-MISC-zip/","link":"","permalink":"http://yoursite.com/2020/02/16/BUUCTF-MISC-zip/","excerpt":"在刷BUU时碰到这题(题目地址)，题目给出了许多压缩包，但是没有一点头绪，看了看别人的wp才知道是crc爆破，在此记录一下这个知识点。","text":"在刷BUU时碰到这题(题目地址)，题目给出了许多压缩包，但是没有一点头绪，看了看别人的wp才知道是crc爆破，在此记录一下这个知识点。 正文CRC全称Cyclic Redundancy Check，也就是循环冗余校验码，是一种能力相当强的检错、纠错码，并且实现编码和检码的电路比较简单，常用于串行传送（二进制位串沿一条信号线逐位传送）的辅助存储器与主机的数据通信和计算机网络中。总而言之，就是每一个文件都有它唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但通常只适用于较小文本文件。自己写的脚本总出错，于是借用了大佬的脚本https://blog.csdn.net/u011377996/article/details/79360820 1234567891011121314151617181920212223242526import zipfileimport stringimport binasciidef CrackCrc(crc): for i in dic: for j in dic: for k in dic: for h in dic: s = i + j + k + h if crc == (binascii.crc32(s.encode())): f.write(s) returndef CrackZip(): for i in range(0,68): file = 'out'+str(i)+'.zip' crc = zipfile.ZipFile(file,'r').getinfo('data.txt').CRC CrackCrc(crc)dic = string.ascii_letters + string.digits + '+/='f = open('out.txt','w')CrackZip()print(\"CRC32碰撞完成\")f.close 碰撞完成后得到一串base64编码，解码一看，要修复文件查了点资料后发现这是一个rar压缩包 https://blog.csdn.net/vevenlcf/article/details/51538837，修改一下文件，在文件前面加上补上52 61 72 21 1A 07 00 后保存打开压缩包一看，在备注处看到flag","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://yoursite.com/tags/MISC/"}]},{"title":"BUUCTF Misc部分wp（二）","slug":"BUUCTF-Misc部分wp（二）","date":"2020-02-12T13:57:01.000Z","updated":"2020-06-01T11:57:50.256Z","comments":true,"path":"2020/02/12/BUUCTF-Misc部分wp（二）/","link":"","permalink":"http://yoursite.com/2020/02/12/BUUCTF-Misc%E9%83%A8%E5%88%86wp%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"涉及的知识点： 英语┭┮﹏┭┮ gnuplot的使用 steghide隐写 lsb隐写","text":"涉及的知识点： 英语┭┮﹏┭┮ gnuplot的使用 steghide隐写 lsb隐写 snake得到一张图片，发现zip，foremost解压得到密钥和一份已加密的文件，将密钥base64解码后1What is Nicki Minaj&#39;s favorite song that refers to snakes?密钥就是anaconda，那么关于蛇的加密方式就是serpent加密（也是关于蛇的单词┭┮﹏┭┮，记得在密码学课上讲过，好像是AES竞选之一，但忘完了(⊙o⊙)…）在线解密：http://serpent.online-domain-tools.com/ 梅花香自苦寒来winhex下发现大量数据，猜测是hex编码随便使用一个16进制编译器将这些编码保存，我这使用的是HxD然后写脚本将它们转成ASCII码（个人比较懒，直接在线解码了）然后发现是一大堆坐标，使用gnuplot绘制图片，首先还是要写脚本将坐标转成gnuplot能识别的形式（除去“（”，“，”和“）”） 12345with open('1.txt','r') as a: a = a.read()b = open('2.txt','w')for i in f.split('\\n'): b.write(i.lstrip('(').rstrip(')').replace(',',' ')+'\\n') 最后扫码得到flag 九连环binwalk先分析发现zip，解压出来发现一张图片需要密码，而压缩包不用，用winhex打开发现是一个伪加密（伪加密具体详情），此处将01 08改为00 08解压出的图片应该就是flag压缩包密码的线索，然后对这个图片各种分析无果，最后去看了其他大佬的wp，才知道一个隐写神器：steghide（详情） 12345将secret.txt文件隐藏到a.jpg中：#steghide embed -cf a.jpg -ef secret.txt -p 123（-p表示密码）从a.jpg解出secret.txt：#steghide extract -sf a.jpg -p 123 这题没有说要密码，直接提取出ko.txt，解压后得到flag 弱口令本以为真的是弱口令，找了个字典爆破，爆破不出来，然后打开压缩包发现注释（看了好久。。。）保存到sublime，是摩斯密码，解密后发现还是打不开压缩包，把字母换成大写就打开了，然后得到一张图片。。。看了半天也分析不出来个啥，就去看了看wp，原来是lsb隐写，那就直接GitHub上的一个工具https://github.com/livz/cloacked-pixel12python lsb.py extract 女神.png 0.txt 123456弱密码猜123456得到0.txt打开即有flag","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://yoursite.com/tags/MISC/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]},{"title":"BUUCTF Misc部分wp（一）","slug":"BUUCTF-Misc部分wp（一）","date":"2020-02-05T06:06:52.000Z","updated":"2020-06-01T11:56:51.664Z","comments":true,"path":"2020/02/05/BUUCTF-Misc部分wp（一）/","link":"","permalink":"http://yoursite.com/2020/02/05/BUUCTF-Misc%E9%83%A8%E5%88%86wp%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"最近开始刷BUUCTF，感觉题目比较基础，而且这还有许多比赛题目的复现。这里将记录一些简单的MISC题目，较难的题目将单独写出来。","text":"最近开始刷BUUCTF，感觉题目比较基础，而且这还有许多比赛题目的复现。这里将记录一些简单的MISC题目，较难的题目将单独写出来。 1.金三胖题目给出了一张gif图，放入Stegsolve中逐帧查看，得到flag 2.二维码一张二维码，首先扫描一下，明显不是flag，在kali中binwalk分析一波发现一个压缩包，使用foremost命令或者binwalk -e命令将压缩包提取出来发现是一个密码为四位数字的压缩包fcrackzip -b -c1 -l 4 -u爆破得到flag 3.N种解决方法下载后发现是一个exe文件，但打不开，使用任意一个文本编译器打开发现是将图片转base64了，把内容复制再转回图片http://tool.chinaz.com/tools/imgtobase，是一个二维码，扫码得到flag 4.大白题目说屏幕太小了估计是改了图片长宽，用winhex打开图片，将01 00改为02 00（对于png文件，其第二行第六列是高度位，改这一位即可）得到flag 5.基础破解暴力破解，使用ARCHPR破解，得到flag 6.你竟然赶我走winhex下分析，发现flag 7.LSB看到LSB，将图片放入Stegsolve中Data Extract分析保存为png后是一张二维码，扫码得到flag 8.乌镇峰会种图同样是winhex下分析，发现flag 9.rarARCHPR破解，得到flag 10.ningen同之前的二维码一样解法 11.文件中的秘密winhex下分析，发现flag 12.wireshark题目给出的是pcap流量包，使用wireshark打开查看http的包搜索flag 13.镜子里面的世界将图片放入Stegsolve中，发现Red、Green和Blue的0通道的图片的最上端有东西接下来用Data Extract查看这三个通道结合起来的东西，发现flag 14.小明的保险箱同之前的二维码一样解法 15.爱因斯坦同样是binwalk分析后分离出压缩包，不过解压密码在图片备注中 16.被嗅探的流量使用wireshark追踪TCP流，查找得到flag 17.假如给我三天光明给了一张图和一个压缩包，图片下估计为盲文，猜测为压缩包密码盲文解密为：kmdonowg，解压出一段音频，一听为摩斯密码，使用Audacity分析摩斯解密，得flag 18.easycapwireshark追踪TCP流，直接得到flag 19.FLAGwinhex，binwalk后无结果，将图片放入Stegsolve中保存为zip文件，解压后为.elf文件，kali运行得flag（chmod a+x a.txt 等价于 chmod +x a.txt，给所有用户给予a.txt文件可执行权限） 20.另外一个世界winhex下发现一串二进制码，估计是ascii码，8个一组，翻译后得到flag 21.荷兰宽带数据泄露下载解压后得到一个路由器配置文件，使用RouterPassView打开后搜索不到flag，再试试username或者password，结果flag是username 22.隐藏的钥匙winhex下打开文件，搜索发现flag是base64编码，在线解码一下得到flag 23.来首歌吧得到一段音频，使用Audacity分析，发现摩斯密码，解码得到flag 24.后门查杀webshell会报病毒，随便拿杀毒软件一个扫描一下，就得到目的文件文件打开就得到flag 25.神秘龙卷风解压得到一压缩包，提示说密码四位数，ARCHPR破解，打开文件发现是Brainfuck编码，在线解码 26.面具下的flag解压得到的图片binwalk分析发现压缩包，foremost解压后得到一个flag.vmdk的文件（老实说vmdk我也没怎么见过，于是就看了看网上的wp），使用7z解压17z x flag.vmdk解压后得到flag的两部分，ook与Brainfuck在线解码（不太明白为什么7z能解压vmdk文件，而且有趣的是我在Windows下解压不能解压出flag后半段密码，在kali下却能。。。） 27.webshell后门和后门查杀那题一样，杀毒软件一扫完事~~~ 28.被劫持的神秘礼物wireshark打开查询TCP流，发现账号密码，串一起再md5 29.刷新过的图片（知识盲区，唉~~~）F5隐写，参考论文：https://wenku.baidu.com/view/c9150e29b4daa58da0114a39.html解题时就直接使用：F5-steganography解压出来一个output.txt，打开一看PK开头，估计是zip，改后缀名，解压后得到flag 30.穿越时空的思恋又是一段音频，Audacity分析，发现摩斯密码，解码得到flag","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://yoursite.com/tags/MISC/"},{"name":"CTF","slug":"CTF","permalink":"http://yoursite.com/tags/CTF/"}]}]}